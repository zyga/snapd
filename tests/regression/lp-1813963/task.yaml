summary: "regression test for LP: #1813963"
prepare: |
    #shellcheck source=tests/lib/snaps.sh
    . "$TESTSLIB"/snaps.sh
    #shellcheck source=tests/lib/dirs.sh
    . "$TESTSLIB"/dirs.sh
    # Install the versatile test snap.
    install_local test-snapd-sh
    # Discard the mount namespace in case the snap has any hooks. We rely on
    # the mount namespace to be absent and about to be constructed in the test
    # below.
    "$LIBEXECDIR"/snapd/snap-discard-ns test-snapd-sh

    # Install a simple service snap. This snap has a single service that just
    # runs for an hour and quits. The point is that it is just one service
    # without anything special about it.
    #
    # For the purpose of the test we want the service to be off.
    install_local test-snapd-simple-service
    systemctl stop snap.test-snapd-simple-service.test-snapd-simple-service.service
    "$LIBEXECDIR"/snapd/snap-discard-ns test-snapd-simple-service

    # Replace snap-update-ns with a fake version that waits for the given
    # amount of time before doing its real work. Since snap-update-ns doesn't
    # have access to real environment craft the script with appropriate paths
    # baked-in from the outside.
    cp "$LIBEXECDIR/snapd/snap-update-ns" ./real-snap-update-ns
    echo '#!/bin/sh -x' > fake-snap-update-ns
    echo 'sleep 100' >> fake-snap-update-ns
    echo 'exec "'"$(pwd)/real-snap-update-ns"'" "$@"' >> fake-snap-update-ns
    chmod 0755 fake-snap-update-ns

    # Replace snap-update-ns in all the places it might exist in.
    mount --bind ./fake-snap-update-ns "$LIBEXECDIR/snapd/snap-update-ns"
    if [ -e "$SNAP_MOUNT_DIR/core/current/" ]; then
        mount --bind ./fake-snap-update-ns "$SNAP_MOUNT_DIR/core/current/usr/lib/snapd/snap-update-ns"
    fi
    if [ -e "$SNAP_MOUNT_DIR/snapd/current/" ]; then
        mount --bind ./fake-snap-update-ns "$SNAP_MOUNT_DIR/snapd/current/usr/lib/snapd/snap-update-ns"
    fi
restore: |
    #shellcheck source=tests/lib/dirs.sh
    . "$TESTSLIB"/dirs.sh
    umount "$LIBEXECDIR/snapd/snap-update-ns" || true
    if [ -e "$SNAP_MOUNT_DIR/core/current/" ]; then
        umount "$SNAP_MOUNT_DIR/core/current/usr/lib/snapd/snap-update-ns" || true
    fi
    if [ -e "$SNAP_MOUNT_DIR/snapd/current/" ]; then
        umount "$SNAP_MOUNT_DIR/snapd/current/usr/lib/snapd/snap-update-ns" || true
    fi

    rm -f real-snap-update-ns
    rm -f fake-snap-update-ns

    snap remove test-snapd-sh
    snap remove test-snapd-simple-service
execute: |
    # When snap-update-ns is artificially slowed down so that snap-confine
    # starts to fail on timeout errors then the exit status from the
    # snap-confine process is the regular "failed" rather than "failed due to
    # signal SIGPIPE".
    set +e
    test-snapd-sh -c /bin/true
    retcode=$?
    set -e
    test "$retcode" -eq 1

    # When we start our simple service it will fail. We anticipate this and
    # explicitly pass --wait that will otherwise wait forever.
    set +e
    systemctl start --wait snap.test-snapd-simple-service.test-snapd-simple-service.service
    retcode=$?
    set -e
    test "$retcode" -eq 1
debug: |
    systemctl status snap.test-snapd-simple-service.test-snapd-simple-service.service

